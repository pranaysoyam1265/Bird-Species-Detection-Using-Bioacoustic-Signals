"""
Bird Audio Metadata Retrieval Script - FIXED VERSION
=====================================================
Phase 0: Xeno-Canto Metadata Construction
Remaining 3521 Recording IDs + Merge with Batch 1

Fixes included:
1. Improved quality extraction (A/B/C/D/E)
2. Duration calculated from WAV files
3. 'recordist' renamed to 'description'
4. Quality flag added (good/poor/unknown)
5. Auto-merge with Batch 1 at completion
"""

import time
import os
import re
import pandas as pd
from datetime import datetime
from tqdm import tqdm

# Selenium imports
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from webdriver_manager.chrome import ChromeDriverManager

# For duration calculation
try:
    import librosa
    LIBROSA_AVAILABLE = True
except ImportError:
    LIBROSA_AVAILABLE = False
    print("âš ï¸ librosa not installed. Duration will be calculated after scraping.")

# ============================================================
# CONFIGURATION
# ============================================================

# Paths
AUDIO_FOLDER = r"C:\Users\prana\OneDrive\Desktop\ML Conf-BioFSL\Audio Recordings"
OUTPUT_FOLDER = r"C:\Users\prana\OneDrive\Desktop\ML Conf-BioFSL"

# Output files
BATCH2_CSV = os.path.join(OUTPUT_FOLDER, "bird_metadata_remaining.csv")
CHECKPOINT_CSV = os.path.join(OUTPUT_FOLDER, "bird_metadata_remaining_checkpoint.csv")
BATCH1_CSV = os.path.join(OUTPUT_FOLDER, "bird_metadata_batch1.csv")
COMPLETE_CSV = os.path.join(OUTPUT_FOLDER, "bird_metadata_complete.csv")
LOG_FILE = os.path.join(OUTPUT_FOLDER, "scraping_log_remaining.txt")

# Scraping settings
REQUEST_DELAY = 2  # seconds between requests
CHECKPOINT_EVERY = 100  # save progress every N recordings
PAGE_LOAD_TIMEOUT = 30  # max seconds to wait for page load

# ============================================================
# REMAINING 3521 RECORDING IDs (After first 1000)
# ============================================================

RECORDING_IDS = [
    "171555", "171727", "171844", "171991", "171994", "171997", "172405", "172420",
    "172423", "172427", "172486", "172487", "172656", "172751", "172752", "172821",
    "172859", "172860", "172875", "172878", "172881", "172882", "172886", "172887",
    "172888", "172889", "172890", "172892", "172893", "172900", "172902", "172914",
    "172915", "172916", "172917", "172919", "172920", "172922", "172934", "172935",
    "172936", "172937", "172939", "172956", "172960", "172962", "172966", "172971",
    "172978", "173148", "173150", "173153", "173154", "173172", "173184", "173254",
    "173257", "173260", "173261", "173263", "173264", "173265", "173267", "173268",
    "173282", "173283", "173306", "173312", "173313", "173315", "173319", "173321",
    "173322", "173361", "174510", "174538", "174834", "174837", "174839", "174869",
    "174959", "175038", "175039", "175222", "175223", "175228", "175254", "175364",
    "175373", "175374", "175534", "175541", "175542", "175543", "175547", "175548",
    "175993", "176255", "176256", "176358", "176368", "176993", "177037", "177042",
    "177043", "177047", "177048", "177049", "177050", "177052", "177054", "177057",
    "177083", "177084", "177087", "177088", "177089", "177098", "177152", "177172",
    "177185", "177187", "177188", "177191", "177192", "177193", "177222", "177224",
    "177225", "177226", "177259", "177260", "177261", "177262", "177352", "177358",
    "177379", "177382", "177384", "177471", "177472", "177477", "177480", "177486",
    "177836", "177839", "178008", "178015", "178016", "178041", "178042", "178046",
    "178129", "178138", "178244", "178310", "178317", "178322", "178480", "178481",
    "178485", "178528", "178552", "178674", "178760", "178761", "178762", "178778",
    "178779", "178840", "178886", "179043", "179064", "179074", "179086", "179092",
    "179095", "179124", "179175", "179178", "179185", "179188", "179304", "179305",
    "179362", "179417", "179466", "179489", "179578", "179600", "179630", "179631",
    "179632", "179643", "179661", "179673", "179708", "179713", "179717", "179727",
    "179730", "179792", "179806", "179810", "179812", "179829", "179830", "179841",
    "179845", "179912", "179959", "179960", "179961", "179962", "180072", "180074",
    "180075", "180077", "180081", "180091", "180092", "180093", "180230", "180259",
    "180666", "180679", "181121", "181184", "181382", "181408", "181417", "181473",
    "181474", "181479", "181482", "181484", "181497", "181621", "181640", "181749",
    "181750", "181751", "181752", "181785", "181956", "182069", "182071", "182073",
    "182078", "182150", "182168", "182171", "182406", "182422", "182546", "182674",
    "182675", "182677", "182680", "182683", "182689", "182735", "183136", "183138",
    "183235", "183280", "183334", "183352", "183357", "183408", "183576", "183580",
    "183590", "183621", "183675", "183801", "183802", "184213", "184306", "184443",
    "184444", "184445", "184458", "184471", "184516", "184627", "184645", "184648",
    "184650", "184710", "184711", "184876", "184879", "184881", "184882", "184962",
    "184964", "184967", "184981", "184982", "184985", "184991", "184993", "185115",
    "185157", "185161", "185245", "185324", "185335", "185513", "185518", "185521",
    "185528", "185568", "185570", "185620", "185621", "185622", "185623", "185624",
    "185812", "185814", "185815", "185817", "185819", "185821", "186284", "186306",
    "186308", "186365", "186366", "186367", "186368", "186399", "186401", "186652",
    "186654", "187320", "187408", "187409", "187411", "187481", "187605", "187606",
    "187607", "187608", "187609", "187634", "187635", "187636", "187637", "187659",
    "187660", "187661", "187663", "187665", "187783", "187980", "188038", "188112",
    "188115", "188119", "188122", "188123", "188125", "188127", "188128", "188130",
    "188177", "188274", "188377", "188430", "188432", "188434", "188493", "188494",
    "188495", "188511", "188539", "188542", "188601", "188668", "188671", "188782",
    "188783", "188784", "188785", "188788", "188813", "188842", "188905", "189042",
    "189043", "189044", "189045", "189057", "189058", "189079", "189262", "189263",
    "189264", "189265", "189266", "189267", "189268", "189269", "189413", "189414",
    "189589", "189590", "189592", "189630", "189808", "189951", "189956", "189972",
    "189973", "190058", "190059", "190060", "190061", "190250", "190292", "190659",
    "190912", "190933", "190934", "190935", "190938", "190939", "190940", "190956",
    "190957", "190958", "190959", "190960", "191024", "191025", "191378", "191379",
    "191488", "191543", "191550", "191952", "191954", "191961", "191962", "191963",
    "191980", "191982", "192011", "192013", "192016", "192018", "192051", "192052",
    "192053", "192054", "192055", "192056", "192057", "192059", "192060", "192061",
    "192078", "192082", "192083", "192099", "192236", "192248", "192487", "192488",
    "192492", "193110", "193111", "193112", "193116", "193127", "193128", "193130",
    "193134", "193411", "193606", "193659", "193660", "193769", "194079", "194087",
    "194088", "194718", "194885", "195032", "195303", "195446", "195540", "195541",
    "195542", "195834", "195835", "196077", "196484", "196488", "196542", "196545",
    "196673", "196689", "196691", "196699", "196858", "197259", "197260", "197261",
    "197263", "197272", "197276", "197400", "197638", "197673", "198054", "198175",
    "198286", "198375", "198397", "198399", "198400", "198499", "198579", "198768",
    "198784", "198785", "198792", "199326", "199356", "199590", "199663", "200103",
    "200508", "200509", "201098", "201427", "202027", "202087", "202749", "202805",
    "202806", "202807", "202808", "203607", "203608", "203709", "203711", "203713",
    "203714", "203716", "203778", "203984", "204418", "205267", "205284", "205287",
    "205288", "205289", "205385", "205389", "205391", "205394", "205395", "205420",
    "205431", "205433", "205468", "205469", "205470", "205473", "205474", "205478",
    "205480", "205482", "205499", "205514", "205515", "205516", "205522", "205523",
    "205757", "205758", "205761", "205772", "205773", "205798", "205807", "205869",
    "205924", "205952", "205982", "205988", "206007", "206008", "206012", "206070",
    "206082", "206087", "206088", "206090", "206155", "206516", "206849", "208363",
    "208627", "208934", "209320", "209321", "209341", "209759", "209760", "209874",
    "209876", "209897", "209898", "210403", "210516", "210518", "210630", "210697",
    "210732", "210744", "210746", "210754", "210758", "210759", "210760", "210761",
    "210762", "210764", "210765", "210766", "210768", "210779", "210839", "210841",
    "210843", "211130", "211292", "211301", "211302", "211305", "211314", "211350",
    "211484", "212025", "212144", "212499", "212528", "212529", "212539", "212575",
    "212577", "212943", "212963", "213058", "213165", "213220", "213558", "213572",
    "214256", "214257", "214259", "215135", "215712", "215757", "215759", "215846",
    "215995", "215998", "216075", "216100", "216178", "216179", "216373", "216509",
    "216516", "216657", "216663", "216779", "216784", "216787", "217005", "217024",
    "217037", "217039", "217046", "217053", "217139", "217753", "217762", "217766",
    "217781", "217783", "217784", "217786", "217792", "217796", "217799", "217801",
    "217802", "217803", "217804", "217806", "217808", "217809", "217811", "217815",
    "217817", "217819", "217823", "217824", "217827", "217829", "217831", "217832",
    "217833", "217834", "217835", "217839", "217841", "217843", "217847", "217851",
    "217853", "217854", "217857", "217858", "217911", "217912", "217913", "217924",
    "217930", "217932", "217940", "217942", "217955", "217970", "217976", "217977",
    "217978", "217979", "217980", "217981", "217982", "217983", "218671", "219352",
    "225350", "232494", "232497", "232504", "232506", "232898", "233132", "233158",
    "233159", "233341", "233342", "233343", "233345", "233346", "233380", "233388",
    "233389", "233403", "233489", "233496", "234215", "234317", "234524", "234550",
    "234669", "234785", "235031", "235054", "235197", "235427", "235490", "235492",
    "235680", "236020", "236409", "236555", "236563", "236564", "236567", "236572",
    "236575", "236697", "236807", "236929", "237263", "237361", "237375", "237517",
    "237743", "237744", "237806", "237821", "237843", "238065", "238074", "238075",
    "238076", "238077", "238264", "239645", "239835", "240177", "240258", "240404",
    "240406", "240675", "240677", "240731", "240940", "240987", "240988", "241102",
    "241103", "241108", "241121", "241134", "241395", "241646", "241821", "243086",
    "243385", "243412", "243586", "243587", "243688", "243775", "243776", "243795",
    "243829", "243969", "243991", "243993", "244350", "244351", "244358", "244458",
    "244459", "244505", "244525", "244526", "244530", "244531", "244573", "244583",
    "244667", "244724", "245645", "245809", "245849", "245875", "245894", "245947",
    "246092", "246110", "246112", "246200", "246539", "2467", "246727", "246756",
    "246776", "246778", "246857", "247259", "247300", "247308", "2476", "247618",
    "247621", "247690", "247768", "247772", "247775", "247799", "247801", "247833",
    "247838", "247851", "248001", "248099", "250549", "250844", "250860", "250999",
    "251802", "251806", "251826", "252006", "252019", "252235", "252396", "252571",
    "252838", "252840", "252931", "253150", "253256", "253317", "253320", "253321",
    "253328", "253360", "253386", "253389", "253397", "253399", "253455", "253520",
    "253521", "253535", "253704", "253718", "253812", "253814", "253842", "253846",
    "253847", "253854", "253921", "253935", "253946", "253947", "253948", "253951",
    "254058", "254062", "254066", "254068", "254071", "254293", "254295", "254296",
    "254298", "254299", "254300", "254301", "254310", "254449", "254456", "254467",
    "254483", "254484", "254489", "254491", "254537", "254552", "254588", "254589",
    "254960", "254962", "255284", "255294", "255438", "255471", "255549", "255631",
    "255824", "255914", "256110", "256195", "256198", "256216", "256292", "256452",
    "256543", "256595", "256731", "256732", "256733", "256734", "256736", "256738",
    "256758", "256759", "256760", "256842", "256847", "256848", "256850", "256889",
    "256893", "256895", "256896", "256898", "256909", "256910", "256913", "256914",
    "256971", "256972", "256974", "256975", "256976", "256977", "256982", "256983",
    "256984", "256985", "256986", "257130", "257286", "257370", "257371", "257372",
    "257401", "259523", "259578", "259620", "260163", "260164", "260167", "260191",
    "260196", "260200", "260204", "260208", "260937", "260938", "260939", "261094",
    "261334", "261335", "261339", "261340", "261341", "261345", "261350", "261423",
    "2628", "262815", "263186", "263187", "263188", "263224", "263236", "263260",
    "263266", "263270", "263347", "263353", "263354", "263371", "263374", "263377",
    "263402", "263404", "263461", "263483", "263484", "263485", "263498", "263634",
    "264267", "264343", "264344", "264715", "264717", "264718", "264719", "265043",
    "265072", "265075", "265076", "265077", "265078", "265422", "265423", "266078",
    "266321", "267262", "267288", "267501", "267502", "267509", "267927", "267948",
    "267950", "267952", "267956", "267958", "267960", "267970", "267971", "267974",
    "267975", "267976", "267982", "267986", "268481", "268646", "268648", "268649",
    "268655", "268658", "268659", "268755", "268815", "269062", "269063", "269082",
    "269097", "269473", "269491", "269493", "269496", "269518", "269737", "269738",
    "269950", "270181", "270182", "270187", "270189", "270192", "270195", "270198",
    "271037", "272153", "272302", "27277", "27545", "275582", "275782", "276906",
    "276993", "277126", "277243", "277334", "277339", "277505", "277506", "277508",
    "277511", "277523", "277550", "277553", "277557", "277562", "277579", "277582",
    "277586", "277590", "277600", "277601", "277602", "277603", "277604", "277605",
    "277637", "277676", "277679", "277742", "277800", "277921", "277930", "277932",
    "277945", "278000", "278074", "278099", "278196", "278350", "278825", "278827",
    "278828", "278925", "278928", "279018", "279134", "279138", "279140", "279142",
    "279143", "279667", "279682", "279719", "279721", "279723", "279738", "282093",
    "282293", "282294", "282295", "282296", "282320", "282410", "282428", "28267",
    "282761", "282797", "282847", "282849", "282989", "283162", "283195", "283396",
    "283403", "283406", "283475", "283536", "283538", "283540", "283608", "283622",
    "283951", "283953", "284019", "284020", "284247", "284485", "284487", "284492",
    "284495", "286399", "286532", "286592", "286644", "286838", "286863", "286946",
    "287459", "287461", "287637", "28786", "287907", "288338", "288339", "288343",
    "288791", "288983", "288984", "288988", "288989", "288994", "289009", "289011",
    "289032", "289049", "289173", "289177", "289181", "289226", "289227", "289357",
    "289367", "289663", "290041", "290042", "290043", "290046", "290133", "290148",
    "290156", "291048", "291049", "291050", "291092", "291107", "291120", "291223",
    "291499", "291617", "291618", "291919", "292085", "292274", "292588", "292673",
    "292765", "292859", "292860", "292919", "293012", "293013", "293125", "293130",
    "293246", "293250", "293291", "293435", "293440", "293615", "293789", "293803",
    "293812", "293898", "293949", "294126", "294130", "294136", "294138", "294191",
    "294204", "294242", "294255", "294256", "294348", "294424", "294460", "294764",
    "295589", "296027", "296046", "296156", "296162", "296164", "296308", "296398",
    "296660", "296725", "296754", "296883", "296884", "296886", "296887", "296888",
    "296892", "296918", "296956", "297296", "297402", "297404", "297437", "297440",
    "297441", "297468", "297504", "297533", "297540", "297543", "297544", "297550",
    "297854", "297982", "298203", "298362", "298363", "298379", "298401", "298451",
    "298561", "298663", "298966", "299017", "299244", "299357", "299501", "299602",
    "299725", "299852", "300049", "300056", "301528", "301529", "301672", "301714",
    "301715", "301850", "301854", "302170", "302249", "302253", "302256", "302322",
    "302517", "302540", "302542", "302548", "302549", "302551", "302573", "302644",
    "302953", "303471", "304269", "304270", "304441", "304446", "304534", "304582",
    "304643", "304644", "304674", "304676", "304677", "304679", "304680", "304681",
    "304789", "304790", "304798", "304800", "304801", "304877", "304879", "304931",
    "305019", "305020", "305022", "305023", "305276", "305762", "305798", "305799",
    "305888", "305896", "306127", "306142", "306144", "306327", "306348", "306351",
    "306387", "306388", "306410", "306438", "306498", "306584", "306680", "306856",
    "307016", "307295", "307445", "307484", "307686", "307817", "307863", "308017",
    "308295", "308302", "308404", "308434", "308474", "308580", "308711", "308712",
    "308762", "309039", "309042", "309043", "309194", "309315", "309318", "309321",
    "309322", "309325", "309326", "309337", "309454", "309534", "309636", "309641",
    "309672", "309697", "309889", "309923", "309926", "309928", "309931", "309933",
    "309994", "309995", "309996", "309997", "309998", "310044", "310045", "310046",
    "310047", "31010", "31011", "31012", "310198", "310199", "310200", "31023",
    "310243", "310256", "310262", "31031", "31047", "31049", "31060", "310670",
    "310840", "310909", "310933", "311050", "311051", "311053", "31114", "31116",
    "31117", "31123", "31124", "31125", "31126", "31127", "31128", "311563",
    "311564", "311622", "311623", "311624", "31180", "311813", "311816", "311850",
    "311852", "311958", "311959", "31202", "31203", "31204", "31205", "31206",
    "312212", "312258", "312529", "312705", "312710", "312718", "312752", "312946",
    "312954", "313062", "313063", "313064", "313065", "31308", "31312", "31313",
    "31314", "31315", "313156", "31316", "313166", "313220", "313272", "313273",
    "313351", "313352", "313353", "313387", "313418", "313463", "313464", "313482",
    "313507", "313532", "313533", "313534", "313677", "313678", "313679", "313680",
    "313681", "313736", "313737", "313739", "313741", "313760", "313762", "313866",
    "313870", "313871", "313877", "314086", "314099", "314138", "314228", "314298",
    "314301", "314413", "314418", "314525", "314647", "314681", "31481", "314839",
    "314840", "314874", "314875", "314923", "314933", "314950", "315082", "315083",
    "315084", "315101", "315204", "315210", "315228", "315277", "315279", "315291",
    "315294", "315295", "315299", "315312", "315314", "315359", "315463", "315579",
    "315598", "315610", "315688", "315704", "315711", "315747", "315750", "315755",
    "315756", "315780", "316009", "316044", "316102", "316162", "316228", "316287",
    "316302", "316436", "316666", "316667", "31670", "316720", "316998", "317040",
    "317079", "317084", "317112", "317114", "317205", "317206", "317245", "317288",
    "317472", "317542", "317544", "317727", "317728", "317729", "317730", "317757",
    "317864", "317903", "317904", "317961", "317972", "318001", "318014", "318019",
    "318131", "318152", "318261", "318283", "318331", "318332", "318349", "318350",
    "318365", "318444", "318456", "318459", "318488", "318677", "318680", "318748",
    "318808", "318899", "318915", "319017", "319022", "319024", "319181", "319246",
    "319372", "319430", "319431", "319516", "319716", "319721", "319722", "319836",
    "319839", "319844", "319908", "319937", "319938", "320057", "320099", "32024",
    "320269", "320357", "320361", "320376", "320377", "320383", "320472", "320485",
    "320488", "320503", "320578", "320711", "320720", "320846", "320886", "321208",
    "321212", "321344", "321389", "321397", "321497", "321529", "321550", "321551",
    "321552", "321631", "321636", "321638", "321692", "321715", "321729", "321730",
    "321731", "321732", "321761", "321768", "321814", "321817", "32182", "32183",
    "32184", "322227", "322292", "322426", "322444", "322478", "322479", "322480",
    "322481", "322488", "322490", "322601", "322604", "322605", "322609", "322611",
    "322618", "322621", "322623", "322626", "322630", "322633", "322635", "322637",
    "322639", "322763", "323143", "323185", "323193", "323200", "323220", "323246",
    "323253", "323308", "323471", "323472", "323474", "323476", "323488", "323704",
    "323974", "323975", "323977", "323979", "323981", "324243", "324272", "324278",
    "324344", "324394", "324402", "324443", "324448", "324480", "324483", "324485",
    "324488", "324491", "324495", "324505", "324509", "324558", "324577", "324581",
    "324820", "324865", "324946", "324947", "324986", "324996", "325000", "325013",
    "325093", "325094", "325096", "325098", "325137", "325191", "32520", "325225",
    "325229", "325262", "325263", "325266", "325267", "325321", "325322", "325344",
    "325347", "325371", "325415", "325432", "325435", "325473", "325494", "325510",
    "325511", "325659", "325696", "325810", "325935", "325943", "326246", "326247",
    "326272", "326495", "326496", "326540", "326542", "326590", "326721", "326730",
    "326857", "327255", "327584", "327648", "327670", "327706", "327739", "327806",
    "327807", "327904", "328180", "328188", "328276", "328540", "328542", "328660",
    "328661", "328698", "328699", "328702", "328703", "328705", "328708", "328709",
    "328710", "328711", "328712", "328715", "328716", "328786", "328787", "328788",
    "328790", "328791", "328792", "328793", "328794", "328796", "328797", "328798",
    "328799", "328801", "328802", "328805", "328835", "328931", "329040", "329235",
    "329682", "330199", "330302", "330312", "330369", "330447", "330449", "330578",
    "330691", "330788", "330861", "331098", "331099", "331198", "331266", "331288",
    "331395", "331421", "331481", "331558", "331564", "331690", "331691", "331741",
    "331742", "331743", "331890", "332054", "332243", "332245", "332328", "332644",
    "332699", "332714", "332719", "332762", "332948", "333146", "333161", "333307",
    "333314", "333385", "333557", "333559", "333582", "333620", "333643", "333650",
    "333905", "333998", "334479", "334685", "334786", "334962", "335125", "335126",
    "335127", "335242", "335495", "335644", "335645", "335646", "335647", "335648",
    "335649", "335650", "335651", "335652", "335695", "335766", "335999", "336000",
    "336248", "336667", "337180", "337469", "337774", "337962", "338164", "338199",
    "338204", "338292", "338492", "338621", "338622", "339565", "339866", "339894",
    "339896", "339897", "339902", "339906", "340139", "340666", "340786", "340787",
    "341005", "341228", "341257", "341450", "341513", "341514", "341515", "341516",
    "341517", "341518", "341521", "341819", "341821", "342060", "342276", "342346",
    "342444", "342555", "342584", "342678", "342803", "342952", "342954", "343837",
    "343867", "343944", "343945", "344092", "344093", "344095", "344096", "344281",
    "344282", "344578", "344965", "345022", "345197", "345874", "345976", "345977",
    "346014", "346022", "346077", "347355", "347979", "348361", "348428", "348433",
    "348507", "348979", "348985", "349091", "349093", "349094", "349095", "349125",
    "349311", "349692", "350052", "350663", "350667", "350672", "350673", "350676",
    "350678", "350680", "350681", "350684", "350750", "350752", "350764", "351038",
    "351041", "351049", "351058", "351065", "351075", "351076", "351078", "351081",
    "351083", "351287", "351289", "351292", "351421", "351422", "351540", "351736",
    "351751", "351864", "352025", "352292", "352964", "353082", "353341", "353369",
    "353539", "353665", "353668", "353723", "354344", "354508", "354509", "354556",
    "354737", "355195", "356414", "356752", "356753", "356754", "356764", "356889",
    "357024", "357969", "357970", "357971", "357977", "358026", "358027", "358052",
    "358508", "358548", "358683", "358700", "358701", "358778", "358779", "358780",
    "358830", "358842", "358844", "358857", "358862", "358903", "358904", "360371",
    "360564", "360916", "360937", "360938", "361021", "361030", "361329", "361336",
    "361479", "361480", "361739", "361741", "361744", "361746", "361807", "361812",
    "361815", "361817", "361916", "361920", "362105", "362208", "362209", "362311",
    "362401", "362459", "362480", "362651", "362960", "363068", "363099", "363175",
    "363216", "363344", "363349", "363366", "363445", "363569", "363749", "363862",
    "363996", "364114", "364282", "364283", "364466", "364468", "364635", "364681",
    "364698", "364709", "365063", "365160", "365936", "365937", "366468", "366599",
    "366627", "366708", "366793", "367004", "367008", "367181", "367190", "367191",
    "367193", "367257", "367272", "367429", "367430", "367530", "367594", "367697",
    "367698", "367798", "367800", "367801", "367802", "367805", "367875", "367878",
    "367886", "368194", "368283", "368287", "368291", "368296", "368297", "368307",
    "368401", "368402", "368420", "368438", "368494", "368513", "368539", "368590",
    "368614", "368615", "368855", "368856", "368940", "368961", "369821", "369822",
    "369969", "369987", "369989", "370064", "370146", "370196", "370240", "370249",
    "370251", "370387", "370490", "370500", "370740", "370786", "370790", "370826",
    "370853", "370857", "370862", "370881", "370892", "370922", "370932", "370949",
    "371033", "371041", "371044", "371048", "371062", "371323", "371412", "371414",
    "371757", "371758", "371759", "371790", "371799", "371800", "371801", "371921",
    "372067", "372211", "372243", "372304", "372305", "372556", "372594", "372603",
    "372607", "372614", "372760", "372790", "372844", "373049", "373480", "373484",
    "373486", "373488", "373499", "373502", "373655", "373783", "373802", "37387",
    "373885", "373906", "373918", "374078", "374086", "374107", "374113", "374596",
    "374636", "374638", "374840", "374898", "375006", "375201", "375276", "375282",
    "375463", "375494", "375505", "375583", "375736", "375826", "375885", "375900",
    "375904", "375947", "375948", "376027", "376029", "376077", "376138", "376180",
    "376182", "376229", "376284", "376298", "376418", "376468", "376569", "376772",
    "376773", "376790", "377094", "377114", "377126", "377144", "377394", "377521",
    "377736", "377799", "377880", "378268", "378412", "378427", "378429", "378600",
    "378602", "378603", "378604", "378605", "378685", "378710", "378969", "378982",
    "379013", "379016", "379035", "379270", "379332", "379573", "379713", "380000",
    "380014", "380017", "380033", "380121", "380122", "380123", "380169", "380185",
    "380186", "380304", "380309", "380321", "380322", "380425", "380526", "380645",
    "380736", "380748", "380761", "381036", "381103", "381110", "381118", "381309",
    "381310", "381323", "381411", "381413", "381414", "381502", "381507", "381535",
    "381579", "381585", "381588", "381591", "381871", "381927", "381981", "382032",
    "382039", "382040", "382084", "382113", "382114", "382119", "382122", "382123",
    "382227", "382347", "382356", "382376", "382447", "382448", "382449", "382450",
    "382451", "382452", "382506", "382730", "382745", "383130", "383332", "383433",
    "383434", "383439", "383440", "383467", "383784", "383822", "383831", "383832",
    "383881", "383905", "383951", "383954", "383960", "383961", "383966", "383972",
    "384003", "384027", "384034", "384058", "384697", "384698", "384905", "384909",
    "384910", "384954", "384955", "385023", "385026", "385027", "385185", "385206",
    "385393", "385601", "385612", "385691", "385817", "385843", "386075", "386616",
    "387173", "387533", "387538", "387850", "388134", "388163", "388164", "388165",
    "388172", "388173", "388255", "388259", "388263", "388267", "388268", "388269",
    "388404", "388493", "388494", "388495", "388500", "388592", "388596", "388611",
    "388682", "388685", "388693", "388694", "388707", "388764", "389096", "389235",
    "389252", "389300", "389303", "389428", "389434", "389493", "389498", "389693",
    "389920", "389960", "389961", "389967", "389979", "389982", "389995", "390105",
    "390183", "390185", "390189", "390276", "390279", "390284", "390471", "390592",
    "390598", "390608", "390824", "390825", "390830", "390831", "390881", "390887",
    "390940", "390941", "391090", "391155", "391156", "391157", "391158", "391566",
    "391570", "391843", "392231", "392266", "392267", "392814", "392842", "392962",
    "392963", "393068", "393129", "393130", "393299", "393498", "393735", "393857",
    "394059", "394107", "394110", "394310", "394526", "394527", "394528", "394529",
    "394737", "394751", "394763", "394834", "394835", "394892", "395154", "395155",
    "395194", "395196", "396159", "396272", "396392", "396690", "397584", "398300",
    "398356", "398477", "399014", "399368", "399828", "399946", "400100", "400542",
    "400852", "400968", "401018", "402349", "402596", "403004", "403005", "403112",
    "404311", "404412", "404418", "404504", "404505", "404628", "404715", "404839",
    "404968", "405617", "405771", "406151", "406160", "406211", "406251", "406258",
    "406300", "406326", "406522", "406523", "406526", "406662", "406871", "406876",
    "406990", "407152", "407173", "407644", "407819", "407827", "407924", "408110",
    "408876", "409062", "409609", "409610", "409818", "410604", "410888", "411047",
    "411318", "411457", "412205", "412672", "412707", "412909", "413030", "413131",
    "413132", "413144", "413175", "413184", "413187", "413188", "413193", "413194",
    "413318", "413334", "413335", "413347", "413356", "413367", "413434", "413435",
    "413436", "413556", "413557", "413723", "413729", "413789", "413800", "413887",
    "414010", "414011", "414021", "414077", "414078", "414551", "414747", "414892",
    "414931", "415384", "415387", "415422", "415436", "415443", "415444", "415596",
    "415782", "415793", "415820", "415889", "416029", "416031", "416032", "416122",
    "416140", "416142", "416294", "416341", "416398", "416400", "416529", "416548",
    "416621", "416745", "416746", "416747", "416780", "416782", "416794", "416814",
    "416815", "416889", "417423", "417442", "417455", "417549", "417728", "417729",
    "417736", "417737", "417855", "417863", "417864", "417904", "417910", "417914",
    "417992", "417993", "418002", "418011", "418016", "418027", "418034", "418074",
    "418082", "418083", "418085", "418092", "418093", "418099", "418101", "418103",
    "418105", "418144", "418235", "418236", "418241", "418266", "418303", "418332",
    "418344", "418346", "418510", "418533", "418657", "418834", "418891", "418893",
    "418918", "419049", "419402", "419704", "419831", "419947", "419996", "420002",
    "420076", "420133", "420250", "420259", "420261", "420397", "420402", "420472",
    "420473", "420494", "420540", "420604", "420721", "420727", "420822", "420842",
    "420844", "420871", "420878", "420879", "420882", "420883", "420886", "420887",
    "420906", "420908", "420909", "420965", "421003", "421160", "421264", "421280",
    "421301", "421303", "421770", "421839", "421940", "422147", "422148", "422421",
    "422424", "422943", "423322", "423357", "423449", "423524", "423591", "423687",
    "423997", "424139", "424140", "424738", "424786", "424789", "425120", "425131",
    "425498", "425505", "425567", "425583", "425775", "425793", "425944", "426167",
    "426201", "426243", "426297", "426298", "427139", "427140", "428282", "428338",
    "428342", "428384", "428385", "428425", "428495", "428701", "428726", "428729",
    "428734", "428762", "428772", "428782", "429022", "429239", "429266", "430015",
    "430726", "430783", "430811", "431030", "431032", "431186", "431633", "431957",
    "432092", "432334", "433031", "433032", "433094", "433166", "433223", "433231",
    "433239", "433389", "433813", "434359", "43470", "435478", "435493", "435715",
    "435717", "436641", "436808", "436809", "436810", "436811", "436820", "436986",
    "436990", "437043", "437510", "437593", "438159", "438455", "439885", "439886",
    "439892", "439893", "439894", "440254", "440560", "440561", "440562", "440573",
    "440574", "440576", "440578", "440579", "440580", "440607", "440639", "441362",
    "441374", "441893", "441895", "441896", "442047", "442320", "442321", "442358",
    "442359", "442508", "442868", "442962", "443181", "443196", "443468", "443522",
    "443764", "443771", "443809", "443812", "444602", "444606", "444622", "444623",
    "444624", "444716", "444946", "444948", "445083", "445610", "445622", "445912",
    "446455", "446457", "446458", "446460", "446462", "446669", "446803", "446806",
    "446889", "446964", "447012", "447324", "447360", "447363", "447415", "448090",
    "448123", "448274", "448720", "448752", "448753", "448778", "448819", "448835",
    "448935", "448937", "448945", "449497", "449502", "449522", "449524", "449552",
    "449553", "450683", "450763", "450764", "450999", "451067", "451207", "451209",
    "451211", "451238", "451239", "451240", "451252", "451253", "451298", "451300",
    "451301", "451302", "451359", "451370", "451371", "451372", "451490", "451721",
    "451735", "451810", "451823", "451857", "451864", "451865", "451898", "452058",
    "452059", "452119", "452150", "452151", "452183", "452505", "452506", "452540",
    "452569", "452609", "452613", "452798", "452806", "452810", "452814", "452816",
    "452980", "453109", "453220", "453916", "453931", "453934", "453936", "453938",
    "453942", "453943", "453944", "454231", "454252", "454402", "454621", "45479",
    "45480", "45481", "454882", "455031", "455035", "455120", "455134", "456644",
    "456917", "457078", "457114", "457137", "457138", "457192", "457444", "458037",
    "459053", "459444", "459466", "459759", "459765", "460094", "460095", "460096",
    "460579", "460588", "460688", "460787", "460832", "460987", "461183", "461195",
    "461240", "461241", "461242", "461521", "461540", "462031", "462046", "462056",
    "462125", "462420", "462421", "462648", "462768", "462769", "462770", "462771",
    "463254", "463255", "463343", "463411", "463860", "464147", "464205", "464355",
    "464508", "464530", "464670", "464765", "464766", "464997", "464999", "465001",
    "465010", "465049", "465050", "465052", "465378", "465621", "465623", "465733",
    "466048", "466164", "466166", "466242", "466407", "466449", "466479", "46690",
    "46691", "466910", "466915", "466928", "467107", "467316", "467689", "467703",
    "467710", "467806", "46803", "468080", "468087", "468243", "468380", "468388",
    "468505", "468991", "469007", "469010", "469328", "469569", "469578", "469596",
    "469603", "469605", "469721", "469745", "469881", "469882", "469883", "469888",
    "469889", "470277", "470553", "470664", "470766", "470771", "470789", "470872",
    "470952", "470954", "471023", "471066", "471244", "471510", "471591", "471705",
    "471775", "471778", "472332", "472345", "473284", "473376", "473410", "473411",
    "473414", "473417", "473427", "473448", "473449", "473676", "473680", "473811",
    "473929", "474064", "474067", "474288", "474615", "474653", "474990", "475086",
    "475090", "475108", "475138", "475141", "475171", "475248", "475251", "475299",
    "475301", "475302", "475315", "475318", "475320", "475679", "475682", "475741",
    "475742", "475967", "476107", "476270", "476272", "476302", "476493", "476494",
    "476496", "476517", "476519", "476522", "476523", "476524", "476525", "476526",
    "476558", "476576", "477136", "477187", "477784", "477807", "477812", "477831",
    "477960", "478449", "478597", "478839", "479499", "479500", "479502", "479504",
    "479507", "479508", "479791", "479795", "479929", "479931", "480052", "480256",
    "48027", "48028", "48029", "480682", "480759", "480761", "480763", "480926",
    "481020", "481130", "481136", "481215", "481816", "481834", "481837", "481858",
    "481933", "481988", "482018", "482163", "482267", "482275", "482276", "482279",
    "482280", "482281", "482295", "482331", "482364", "482493", "482515", "482568",
    "482618", "482783", "482868", "482875", "483020", "483021", "483028", "483030",
    "483145", "483184", "483188", "483190", "483199", "483211", "483212", "483214",
    "483215", "483293", "483295", "483552", "483578", "483628", "483735", "483875",
    "484151", "48445", "48475", "484906", "485817", "485982", "485983", "485984",
    "48609", "486220", "486471", "486563", "486566", "486786", "486798", "486800",
    "486855", "486856", "486857", "486858", "486859", "486860", "487219", "487497",
    "487832", "489429", "490385", "490386", "490508", "490518", "490521", "490934",
    "490936", "491073", "491598", "491610", "491629", "491631", "491632", "491633",
    "491634", "491635", "492146", "492147", "492246", "492291", "492384", "492406",
    "493058", "493266", "493267", "493268", "493338", "493365", "493469", "493470",
    "493543", "493544", "493888", "494032", "494351", "494405", "494421", "494579",
    "494993", "494996", "495007", "495169", "495177", "495178", "495179", "495180",
    "495181", "495182", "495188", "495191", "495244", "495252", "495327", "495411",
    "495420", "495474", "496109", "496280", "496354", "496355", "497156", "497300",
    "497429", "497492", "497494", "497796", "498161", "498255", "498256", "498643",
    "498644", "498645", "499322", "499324", "499561", "500093", "500125", "500139",
    "500350", "500351", "500354", "501250", "501251", "501252", "501253", "501257",
    "501258", "501259", "501260", "501261", "501262", "501459", "501464", "501766",
    "501895", "502311", "502313", "502505", "502629", "503144", "503186", "503191",
    "503194", "504005", "504006", "504150", "504196", "50586", "50587", "50588",
    "50589", "50590", "50591", "50592", "50593", "50594", "50595", "50596",
    "50597", "50598", "50599", "50600", "50601", "50602", "50603", "50604",
    "50605", "50606", "50607", "50608", "50609", "50610", "50661", "51318",
    "51319", "51410", "51411", "51412", "51473", "51474", "51475", "51476",
    "51477", "51699", "51700", "51701", "51754", "51755", "51757", "51758",
    "51759", "51775", "51779", "51862", "51863", "51864", "51865", "51866",
    "51867", "51868", "51879", "52151", "52152", "52153", "52309", "52310",
    "52312", "52314", "52986", "52987", "52988", "53405", "53619", "53620",
    "53695", "53696", "53697", "53698", "53699", "53700", "54285", "54355",
    "54356", "54357", "56416", "56898", "57029", "57384", "57970", "57971",
    "59480", "5986", "59938", "59941", "61168", "65612", "65919", "67143",
    "70185", "70721", "70722", "77879", "77881", "77884", "78342", "78890",
    "78891", "79972", "81290", "81305", "86755", "86760", "8883", "91412",
    "92009", "99571", "99969"
]

# ============================================================
# BROWSER SETUP
# ============================================================

def create_browser():
    """Create and configure Chrome browser"""
    
    print("ðŸŒ Setting up Chrome browser...")
    
    options = Options()
    
    # Visible mode (not headless)
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    options.add_argument('--disable-gpu')
    options.add_argument('--window-size=1920,1080')
    
    # Anti-detection
    options.add_argument('--disable-blink-features=AutomationControlled')
    options.add_experimental_option("excludeSwitches", ["enable-automation"])
    options.add_experimental_option('useAutomationExtension', False)
    
    # User agent
    options.add_argument('--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/144.0.7559.110 Safari/537.36')
    
    print("ðŸ“¥ Downloading/verifying ChromeDriver...")
    service = Service(ChromeDriverManager().install())
    
    driver = webdriver.Chrome(service=service, options=options)
    driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
    
    print("âœ… Browser ready!")
    return driver

# ============================================================
# IMPROVED QUALITY EXTRACTION
# ============================================================

def extract_quality_rating(driver, page_text):
    """
    IMPROVED: Extract actual quality rating (A/B/C/D/E) from page
    Multiple methods to ensure correct extraction
    """
    
    quality = ''
    
    # Method 1: Look for quality rating in specific pattern
    # The page shows current rating highlighted or selected
    try:
        # Look for rating element with specific class
        rating_elements = driver.find_elements(By.CSS_SELECTOR, '.rating-selected, .rating-current, .selected-rating')
        for elem in rating_elements:
            text = elem.text.strip().upper()
            if text in ['A', 'B', 'C', 'D', 'E']:
                return text
    except:
        pass
    
    # Method 2: Look for quality info in page source
    try:
        page_source = driver.page_source
        
        # Pattern: Look for quality indicator before the rating options
        # Often shown as "Quality: A" or similar
        quality_patterns = [
            r'quality[:\s]+([ABCDE])\b',
            r'rating[:\s]+([ABCDE])\b',
            r'\brated\s+([ABCDE])\b',
            r'class="[^"]*rating[^"]*"[^>]*>([ABCDE])<',
            r'>Quality:\s*([ABCDE])<',
            r'data-rating="([ABCDE])"',
        ]
        
        for pattern in quality_patterns:
            match = re.search(pattern, page_source, re.IGNORECASE)
            if match:
                return match.group(1).upper()
    except:
        pass
    
    # Method 3: Find in structured data or metadata
    try:
        # Look for JSON-LD or meta tags
        scripts = driver.find_elements(By.CSS_SELECTOR, 'script[type="application/ld+json"]')
        for script in scripts:
            content = script.get_attribute('innerHTML')
            if 'quality' in content.lower():
                match = re.search(r'"quality"\s*:\s*"([ABCDE])"', content, re.IGNORECASE)
                if match:
                    return match.group(1).upper()
    except:
        pass
    
    # Method 4: Look for the quality display element specifically
    try:
        # Xeno-canto often shows quality as a letter near the rating section
        elements = driver.find_elements(By.XPATH, "//*[contains(text(), 'Quality') or contains(text(), 'Rating')]")
        for elem in elements:
            parent = elem.find_element(By.XPATH, '..')
            parent_text = parent.text
            # Look for single letter A-E after Quality/Rating text
            match = re.search(r'(?:Quality|Rating)[:\s]*([ABCDE])\b', parent_text, re.IGNORECASE)
            if match:
                return match.group(1).upper()
    except:
        pass
    
    # Method 5: Check page text for quality patterns
    try:
        # Look for the quality letter that appears independently
        # Avoid matching "ABCDE" as a group (which is the rating options)
        lines = page_text.split('\n')
        for i, line in enumerate(lines):
            if 'quality' in line.lower() or 'rating' in line.lower():
                # Check next few lines for single letter
                for j in range(i, min(i+3, len(lines))):
                    stripped = lines[j].strip()
                    if stripped in ['A', 'B', 'C', 'D', 'E']:
                        return stripped
    except:
        pass
    
    # Method 6: Look for highlighted/bold quality letter
    try:
        # Sometimes the current quality is in a span with special styling
        quality_spans = driver.find_elements(By.CSS_SELECTOR, 'span.quality, span.rating, .sound-quality')
        for span in quality_spans:
            text = span.text.strip().upper()
            if text in ['A', 'B', 'C', 'D', 'E']:
                return text
    except:
        pass
    
    return quality

# ============================================================
# METADATA EXTRACTION
# ============================================================

def parse_title_for_species(title):
    """Parse page title to extract species info"""
    try:
        title = re.sub(r'^XC\d+\s*', '', title)
        title = re.sub(r'\s*::\s*xeno-canto.*$', '', title, flags=re.IGNORECASE)
        
        scientific_match = re.search(r'\(([^)]+)\)', title)
        scientific_name = scientific_match.group(1) if scientific_match else ''
        
        english_name = re.sub(r'\s*\([^)]+\)\s*', '', title).strip()
        
        genus = ''
        species = ''
        subspecies = ''
        if scientific_name:
            parts = scientific_name.split()
            if len(parts) >= 1:
                genus = parts[0]
            if len(parts) >= 2:
                species = parts[1]
            if len(parts) >= 3:
                subspecies = ' '.join(parts[2:])
        
        return english_name, scientific_name, genus, species, subspecies
    except:
        return '', '', '', '', ''

def scrape_recording_page(driver, recording_id):
    """Scrape metadata from a single Xeno-Canto recording page - IMPROVED VERSION"""
    
    url = f"https://xeno-canto.org/{recording_id}"
    
    metadata = {
        'recording_id': f"XC{recording_id}",
        'scientific_name': '',
        'genus': '',
        'species': '',
        'subspecies': '',
        'english_name': '',
        'call_type': '',
        'sex': '',
        'life_stage': '',
        'duration_seconds': '',
        'date': '',
        'time': '',
        'country': '',
        'location': '',
        'latitude': '',
        'longitude': '',
        'altitude': '',
        'quality': '',
        'quality_flag': '',
        'description': '',  # Renamed from 'recordist'
        'license': '',
        'remarks': '',
        'background_species': '',
        'status': 'success'
    }
    
    try:
        driver.get(url)
        
        # Wait for page to load
        max_wait = PAGE_LOAD_TIMEOUT
        start = time.time()
        while time.time() - start < max_wait:
            title = driver.title.lower()
            if 'anubis' not in title and 'xeno-canto' in title:
                break
            time.sleep(0.5)
        
        time.sleep(1.5)  # Extra wait for dynamic content
        
        page_title = driver.title
        if 'anubis' in page_title.lower() or not page_title:
            metadata['status'] = 'blocked_by_anubis'
            return metadata
        
        if '404' in page_title or 'not found' in page_title.lower():
            metadata['status'] = 'not_found'
            return metadata
        
        # Extract species from title
        english_name, scientific_name, genus, species, subspecies = parse_title_for_species(page_title)
        metadata['english_name'] = english_name
        metadata['scientific_name'] = scientific_name
        metadata['genus'] = genus
        metadata['species'] = species
        metadata['subspecies'] = subspecies
        
        # Get page text
        try:
            body = driver.find_element(By.TAG_NAME, "body")
            page_text = body.text
        except:
            page_text = ''
        
        # IMPROVED: Extract quality rating
        metadata['quality'] = extract_quality_rating(driver, page_text)
        
        # Set quality flag
        if metadata['quality'] in ['A', 'B', 'C']:
            metadata['quality_flag'] = 'good'
        elif metadata['quality'] in ['D', 'E']:
            metadata['quality_flag'] = 'poor'
        else:
            metadata['quality_flag'] = 'unknown'
        
        # Extract call type
        call_type_match = re.search(r'Â·\s*(song|call|alarm|flight|duet|drumming|display|begging|[a-z\s]+call|[a-z\s]+song)', page_text.lower())
        if call_type_match:
            metadata['call_type'] = call_type_match.group(1).strip()
        
        # Extract recordist/description
        recordist_match = re.search(r'Recordist\s*\n\s*([^\n]+)', page_text)
        if recordist_match:
            metadata['description'] = recordist_match.group(1).strip()
        
        # Date
        date_match = re.search(r'Date\s*\n?\s*(\d{4}-\d{2}-\d{2})', page_text)
        if date_match:
            metadata['date'] = date_match.group(1)
        
        # Time
        time_match = re.search(r'Time\s*\n?\s*(\d{1,2}:\d{2})', page_text)
        if time_match:
            metadata['time'] = time_match.group(1)
        
        # Latitude
        lat_match = re.search(r'Latitude\s*\n?\s*([-\d.]+)', page_text)
        if lat_match:
            metadata['latitude'] = lat_match.group(1)
        
        # Longitude
        lng_match = re.search(r'Longitude\s*\n?\s*([-\d.]+)', page_text)
        if lng_match:
            metadata['longitude'] = lng_match.group(1)
        
        # Location
        loc_match = re.search(r'Location\s*\n\s*([^\n]+)', page_text)
        if loc_match:
            metadata['location'] = loc_match.group(1).strip()
        
        # Country
        country_match = re.search(r'Country\s*\n\s*([^\n]+)', page_text)
        if country_match:
            metadata['country'] = country_match.group(1).strip()
        elif metadata['location']:
            parts = metadata['location'].split(',')
            if len(parts) > 1:
                metadata['country'] = parts[-1].strip()
        
        # Altitude
        alt_match = re.search(r'(?:Elevation|Altitude)\s*\n?\s*(\d+)\s*m', page_text)
        if alt_match:
            metadata['altitude'] = alt_match.group(1)
        
        # License
        license_match = re.search(r'(Creative Commons[^\n]+)', page_text)
        if license_match:
            metadata['license'] = license_match.group(1).strip()
        
        # Remarks
        remarks_match = re.search(r'Remarks from the Recordist\s*\n\s*([^\n]+(?:\n[^\n]+)*?)(?=\nLocation|\nRating|\nCitation|$)', page_text)
        if remarks_match:
            metadata['remarks'] = remarks_match.group(1).strip()[:500]
        
        # Sex and life stage
        if 'male' in page_text.lower():
            if 'female' in page_text.lower():
                metadata['sex'] = 'male, female'
            else:
                metadata['sex'] = 'male'
        elif 'female' in page_text.lower():
            metadata['sex'] = 'female'
        
        if 'juvenile' in page_text.lower():
            metadata['life_stage'] = 'juvenile'
        elif 'immature' in page_text.lower():
            metadata['life_stage'] = 'immature'
        elif 'adult' in page_text.lower():
            metadata['life_stage'] = 'adult'
        
        # Background species
        bg_match = re.search(r'(?:Background|Also recorded)[:\s]*([^\n]+)', page_text, re.IGNORECASE)
        if bg_match:
            metadata['background_species'] = bg_match.group(1).strip()[:200]
        
        return metadata
        
    except Exception as e:
        metadata['status'] = f'error: {str(e)[:100]}'
        return metadata

# ============================================================
# DURATION CALCULATION
# ============================================================

def calculate_durations(df):
    """Calculate duration from WAV files using librosa"""
    
    if not LIBROSA_AVAILABLE:
        print("âš ï¸ librosa not available. Skipping duration calculation.")
        return df
    
    print("\nðŸ• Calculating durations from WAV files...")
    
    import librosa
    
    durations = []
    for idx, row in tqdm(df.iterrows(), total=len(df), desc="Calculating durations"):
        recording_id = row['recording_id']
        filename = f"{recording_id}.wav"
        filepath = os.path.join(AUDIO_FOLDER, filename)
        
        try:
            if os.path.exists(filepath):
                duration = librosa.get_duration(path=filepath)
                durations.append(round(duration, 2))
            else:
                durations.append('')
        except Exception as e:
            durations.append('')
    
    df['duration_seconds'] = durations
    
    valid_count = sum(1 for d in durations if d != '')
    print(f"   âœ… Calculated {valid_count}/{len(df)} durations")
    
    return df

# ============================================================
# CHECKPOINT FUNCTIONS
# ============================================================

def load_checkpoint():
    """Load existing checkpoint if available"""
    if os.path.exists(CHECKPOINT_CSV):
        try:
            df = pd.read_csv(CHECKPOINT_CSV)
            processed_ids = set(df['recording_id'].str.replace('XC', '').tolist())
            print(f"ðŸ“‚ Loaded checkpoint: {len(processed_ids)} recordings already processed")
            return df.to_dict('records'), processed_ids
        except Exception as e:
            print(f"âš ï¸ Could not load checkpoint: {e}")
            return [], set()
    return [], set()

def save_checkpoint(metadata_list):
    """Save current progress to checkpoint file"""
    try:
        df = pd.DataFrame(metadata_list)
        df.to_csv(CHECKPOINT_CSV, index=False, encoding='utf-8-sig')
    except Exception as e:
        print(f"âš ï¸ Could not save checkpoint: {e}")

def log_message(message):
    """Write message to log file"""
    try:
        with open(LOG_FILE, 'a', encoding='utf-8') as f:
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            f.write(f"[{timestamp}] {message}\n")
    except:
        pass

# ============================================================
# LOCAL FILE CHECKING
# ============================================================

def add_local_file_info(df):
    """Add local file path and existence info"""
    
    print("\nðŸ” Checking local file existence...")
    
    local_paths = []
    file_exists = []
    
    for idx, row in df.iterrows():
        recording_id = row['recording_id']
        filename = f"{recording_id}.wav"
        filepath = os.path.join(AUDIO_FOLDER, filename)
        local_paths.append(filepath)
        file_exists.append(os.path.exists(filepath))
    
    df['local_file_path'] = local_paths
    df['file_exists'] = file_exists
    
    found_count = sum(file_exists)
    print(f"   âœ… Found {found_count}/{len(df)} local files")
    
    return df

# ============================================================
# MERGE WITH BATCH 1
# ============================================================

def merge_with_batch1(df_remaining):
    """Merge remaining recordings with Batch 1"""
    
    print("\n" + "="*60)
    print("ðŸ”— MERGING WITH BATCH 1")
    print("="*60)
    
    if not os.path.exists(BATCH1_CSV):
        print(f"âš ï¸ Batch 1 CSV not found: {BATCH1_CSV}")
        print("   Saving remaining batch only.")
        return df_remaining
    
    # Load Batch 1
    print(f"ðŸ“‚ Loading Batch 1: {BATCH1_CSV}")
    df_batch1 = pd.read_csv(BATCH1_CSV)
    print(f"   Batch 1 records: {len(df_batch1)}")
    
    # Fix Batch 1 column names if needed
    if 'recordist' in df_batch1.columns and 'description' not in df_batch1.columns:
        df_batch1 = df_batch1.rename(columns={'recordist': 'description'})
        print("   âœ… Renamed 'recordist' to 'description' in Batch 1")
    
    # Add quality_flag to Batch 1 if missing
    if 'quality_flag' not in df_batch1.columns:
        def classify_quality(q):
            if pd.isna(q) or q == '':
                return 'unknown'
            q = str(q).upper().strip()
            if q in ['A', 'B', 'C']:
                return 'good'
            elif q in ['D', 'E']:
                return 'poor'
            else:
                return 'unknown'
        
        df_batch1['quality_flag'] = df_batch1['quality'].apply(classify_quality)
        print("   âœ… Added 'quality_flag' to Batch 1")
    
    # Ensure both DataFrames have same columns
    all_columns = list(set(df_batch1.columns) | set(df_remaining.columns))
    
    for col in all_columns:
        if col not in df_batch1.columns:
            df_batch1[col] = ''
        if col not in df_remaining.columns:
            df_remaining[col] = ''
    
    # Define column order
    column_order = [
        'recording_id', 'scientific_name', 'genus', 'species', 'subspecies',
        'english_name', 'call_type', 'sex', 'life_stage', 'duration_seconds',
        'date', 'time', 'country', 'location', 'latitude', 'longitude',
        'altitude', 'quality', 'quality_flag', 'description', 'license', 'remarks',
        'background_species', 'local_file_path', 'file_exists', 'status'
    ]
    
    # Add any extra columns not in the order
    for col in all_columns:
        if col not in column_order:
            column_order.append(col)
    
    # Reorder columns
    df_batch1 = df_batch1[[c for c in column_order if c in df_batch1.columns]]
    df_remaining = df_remaining[[c for c in column_order if c in df_remaining.columns]]
    
    # Concatenate
    print(f"   Remaining batch records: {len(df_remaining)}")
    df_complete = pd.concat([df_batch1, df_remaining], ignore_index=True)
    print(f"   âœ… Total merged records: {len(df_complete)}")
    
    # Remove duplicates if any
    original_len = len(df_complete)
    df_complete = df_complete.drop_duplicates(subset=['recording_id'], keep='last')
    if len(df_complete) < original_len:
        print(f"   âš ï¸ Removed {original_len - len(df_complete)} duplicate records")
    
    return df_complete

# ============================================================
# SUMMARY REPORT
# ============================================================

def generate_summary_report(metadata_df, batch_name="COMPLETE"):
    """Generate a summary report of the metadata"""
    
    print("\n" + "="*60)
    print(f"ðŸ“Š METADATA SUMMARY REPORT - {batch_name}")
    print("="*60)
    
    total = len(metadata_df)
    successful = len(metadata_df[metadata_df['status'] == 'success'])
    failed = total - successful
    
    print(f"\nðŸ“ Total recordings: {total}")
    print(f"âœ… Successfully retrieved: {successful} ({100*successful/total:.1f}%)")
    print(f"âŒ Failed/Not found: {failed} ({100*failed/total:.1f}%)")
    
    if successful > 0:
        success_df = metadata_df[metadata_df['status'] == 'success']
        
        # Species count
        if 'scientific_name' in success_df.columns:
            species_counts = success_df['scientific_name'].value_counts()
            unique_species = len(species_counts[species_counts.index != ''])
            print(f"\nðŸ¦ Unique species found: {unique_species}")
            
            if unique_species > 0:
                print(f"\nðŸ“‹ Top 15 species by recording count:")
                print("-"*45)
                for i, (sp, count) in enumerate(species_counts.head(15).items(), 1):
                    if sp:
                        print(f"   {i:2d}. {sp}: {count}")
        
        # Country distribution
        if 'country' in success_df.columns:
            country_counts = success_df['country'].value_counts()
            unique_countries = len(country_counts[country_counts.index != ''])
            print(f"\nðŸŒ Countries represented: {unique_countries}")
            
            if unique_countries > 0:
                print(f"\nðŸ—ºï¸ Top 10 countries:")
                print("-"*45)
                for country, count in country_counts.head(10).items():
                    if country:
                        print(f"   {country}: {count}")
        
        # Quality distribution
        if 'quality' in success_df.columns:
            quality_counts = success_df['quality'].value_counts()
            print(f"\nâ­ Quality distribution:")
            print("-"*45)
            for quality, count in sorted(quality_counts.items()):
                if quality:
                    print(f"   Quality {quality}: {count}")
        
        # Quality flag distribution
        if 'quality_flag' in success_df.columns:
            flag_counts = success_df['quality_flag'].value_counts()
            print(f"\nðŸš© Quality flag distribution:")
            print("-"*45)
            for flag, count in flag_counts.items():
                percentage = 100 * count / len(success_df)
                print(f"   {flag}: {count} ({percentage:.1f}%)")
        
        # Call type distribution
        if 'call_type' in success_df.columns:
            call_types = success_df['call_type'].value_counts()
            print(f"\nðŸŽµ Call types (top 10):")
            print("-"*45)
            for call_type, count in call_types.head(10).items():
                if call_type:
                    print(f"   {call_type}: {count}")
        
        # Duration statistics
        if 'duration_seconds' in success_df.columns:
            valid_durations = pd.to_numeric(success_df['duration_seconds'], errors='coerce').dropna()
            if len(valid_durations) > 0:
                print(f"\nðŸ• Duration statistics:")
                print("-"*45)
                print(f"   Recordings with duration: {len(valid_durations)}")
                print(f"   Min: {valid_durations.min():.2f} seconds")
                print(f"   Max: {valid_durations.max():.2f} seconds")
                print(f"   Mean: {valid_durations.mean():.2f} seconds")
                print(f"   Total: {valid_durations.sum()/3600:.2f} hours")
    
    # Local files
    if 'file_exists' in metadata_df.columns:
        existing = metadata_df['file_exists'].sum()
        print(f"\nðŸ’¾ Local WAV files found: {existing}/{total} ({100*existing/total:.1f}%)")
    
    # Failed recordings
    if failed > 0:
        print(f"\nâš ï¸ Failed recordings status breakdown:")
        print("-"*45)
        failed_df = metadata_df[metadata_df['status'] != 'success']
        status_counts = failed_df['status'].value_counts()
        for status, count in status_counts.items():
            print(f"   {status}: {count}")
    
    print("\n" + "="*60)

# ============================================================
# MAIN EXECUTION
# ============================================================

def main():
    print("="*60)
    print("ðŸ¦ BIRD AUDIO METADATA RETRIEVAL - REMAINING 3521 IDs")
    print("   Phase 0: Xeno-Canto Metadata Construction")
    print("   IMPROVED VERSION with Quality Fix")
    print("="*60)
    print(f"\nðŸ“… Started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"ðŸ“ Audio folder: {AUDIO_FOLDER}")
    print(f"ðŸ“„ Output (remaining): {BATCH2_CSV}")
    print(f"ðŸ“„ Output (complete): {COMPLETE_CSV}")
    print(f"â±ï¸ Request delay: {REQUEST_DELAY} seconds")
    print(f"ðŸ’¾ Checkpoint every: {CHECKPOINT_EVERY} recordings")
    print(f"ðŸ“Š Total IDs to process: {len(RECORDING_IDS)}")
    
    estimated_time = len(RECORDING_IDS) * (REQUEST_DELAY + 1) / 60
    print(f"â³ Estimated time: ~{estimated_time:.0f} minutes (~{estimated_time/60:.1f} hours)")
    
    log_message("="*50)
    log_message("Starting remaining 3521 IDs scraping")
    
    # Check if audio folder exists
    if not os.path.exists(AUDIO_FOLDER):
        print(f"\nâš ï¸ Warning: Audio folder does not exist: {AUDIO_FOLDER}")
        print("   Duration calculation and file checking will fail.")
    
    # Load checkpoint if exists
    all_metadata, processed_ids = load_checkpoint()
    
    # Filter out already processed IDs
    ids_to_process = [rid for rid in RECORDING_IDS if rid not in processed_ids]
    
    if len(ids_to_process) == 0:
        print("\nâœ… All recordings already processed! Loading from checkpoint...")
        df_remaining = pd.DataFrame(all_metadata)
    else:
        print(f"\nðŸ”„ Recordings to process: {len(ids_to_process)}")
        if len(processed_ids) > 0:
            print(f"   (Resuming from checkpoint, {len(processed_ids)} already done)")
        
        remaining_time = len(ids_to_process) * (REQUEST_DELAY + 1) / 60
        print(f"â³ Remaining time: ~{remaining_time:.0f} minutes")
        
        input("\nðŸš€ Press ENTER to start scraping (browser will open)...")
        
        # Create browser
        driver = None
        try:
            driver = create_browser()
            
            # Process recordings with progress bar
            for i, rec_id in enumerate(tqdm(ids_to_process, desc="Scraping metadata")):
                try:
                    # Scrape metadata
                    metadata = scrape_recording_page(driver, rec_id)
                    all_metadata.append(metadata)
                    
                    # Log progress
                    status = metadata.get('status', 'unknown')
                    quality = metadata.get('quality', '')
                    if status != 'success':
                        log_message(f"XC{rec_id}: {status}")
                    elif quality:
                        log_message(f"XC{rec_id}: quality={quality}")
                    
                    # Save checkpoint periodically
                    if len(all_metadata) % CHECKPOINT_EVERY == 0:
                        save_checkpoint(all_metadata)
                        tqdm.write(f"   ðŸ’¾ Checkpoint saved: {len(all_metadata)} recordings")
                        log_message(f"Checkpoint saved: {len(all_metadata)} recordings")
                    
                    # Respect rate limiting
                    time.sleep(REQUEST_DELAY)
                    
                except Exception as e:
                    error_msg = f"Error processing XC{rec_id}: {str(e)[:100]}"
                    tqdm.write(f"   âš ï¸ {error_msg}")
                    log_message(error_msg)
                    all_metadata.append({
                        'recording_id': f"XC{rec_id}",
                        'status': f'error: {str(e)[:100]}'
                    })
                    time.sleep(REQUEST_DELAY)
            
            # Final checkpoint save
            save_checkpoint(all_metadata)
            
        except KeyboardInterrupt:
            print("\n\nâš ï¸ Interrupted by user! Saving progress...")
            save_checkpoint(all_metadata)
            log_message("Interrupted by user - checkpoint saved")
            
        except Exception as e:
            print(f"\nâŒ Critical error: {e}")
            log_message(f"Critical error: {e}")
            save_checkpoint(all_metadata)
            
        finally:
            # Close browser
            if driver:
                print("\nðŸ”’ Closing browser...")
                try:
                    driver.quit()
                except:
                    pass
        
        # Convert to DataFrame
        df_remaining = pd.DataFrame(all_metadata)
    
    # Add local file info
    df_remaining = add_local_file_info(df_remaining)
    
    # Calculate durations from WAV files
    if LIBROSA_AVAILABLE:
        df_remaining = calculate_durations(df_remaining)
    
    # Ensure all expected columns exist
    expected_columns = [
        'recording_id', 'scientific_name', 'genus', 'species', 'subspecies',
        'english_name', 'call_type', 'sex', 'life_stage', 'duration_seconds',
        'date', 'time', 'country', 'location', 'latitude', 'longitude',
        'altitude', 'quality', 'quality_flag', 'description', 'license', 'remarks',
        'background_species', 'local_file_path', 'file_exists', 'status'
    ]
    
    for col in expected_columns:
        if col not in df_remaining.columns:
            df_remaining[col] = ''
    
    # Save remaining batch CSV
    df_remaining.to_csv(BATCH2_CSV, index=False, encoding='utf-8-sig')
    print(f"\nâœ… Remaining batch saved to: {BATCH2_CSV}")
    log_message(f"Remaining batch saved to: {BATCH2_CSV}")
    
    # Generate summary for remaining batch
    print("\n" + "ðŸ”„"*30)
    generate_summary_report(df_remaining, "REMAINING 3521 IDs")
    
    # Merge with Batch 1
    df_complete = merge_with_batch1(df_remaining)
    
    # Calculate durations for Batch 1 records if missing
    if LIBROSA_AVAILABLE:
        # Check if any durations are missing
        missing_duration = df_complete['duration_seconds'].isna() | (df_complete['duration_seconds'] == '')
        if missing_duration.sum() > 0:
            print(f"\nðŸ• Calculating missing durations ({missing_duration.sum()} records)...")
            df_complete = calculate_durations(df_complete)
    
    # Save complete merged CSV
    df_complete.to_csv(COMPLETE_CSV, index=False, encoding='utf-8-sig')
    print(f"\nâœ… Complete metadata saved to: {COMPLETE_CSV}")
    log_message(f"Complete metadata saved to: {COMPLETE_CSV}")
    
    # Generate complete summary
    print("\n" + "ðŸŽ‰"*30)
    generate_summary_report(df_complete, "COMPLETE DATASET (4521 IDs)")
    
    # Save summary to text file
    summary_file = COMPLETE_CSV.replace('.csv', '_summary.txt')
    with open(summary_file, 'w', encoding='utf-8') as f:
        f.write("METADATA SUMMARY REPORT - COMPLETE DATASET\n")
        f.write("="*60 + "\n\n")
        f.write(f"Generated at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
        f.write(f"Total recordings: {len(df_complete)}\n")
        f.write(f"Successfully retrieved: {len(df_complete[df_complete['status'] == 'success'])}\n")
        
        if 'scientific_name' in df_complete.columns:
            unique_species = df_complete[df_complete['status'] == 'success']['scientific_name'].nunique()
            f.write(f"Unique species: {unique_species}\n")
        
        if 'quality_flag' in df_complete.columns:
            f.write(f"\nQuality distribution:\n")
            for flag in ['good', 'poor', 'unknown']:
                count = (df_complete['quality_flag'] == flag).sum()
                f.write(f"  {flag}: {count}\n")
        
        if 'file_exists' in df_complete.columns:
            f.write(f"\nLocal files found: {df_complete['file_exists'].sum()}\n")
        
        if 'duration_seconds' in df_complete.columns:
            valid_durations = pd.to_numeric(df_complete['duration_seconds'], errors='coerce').dropna()
            if len(valid_durations) > 0:
                f.write(f"\nDuration statistics:\n")
                f.write(f"  Recordings with duration: {len(valid_durations)}\n")
                f.write(f"  Total duration: {valid_durations.sum()/3600:.2f} hours\n")
    
    print(f"ðŸ“„ Summary saved to: {summary_file}")
    print(f"\nðŸ“… Completed at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    log_message(f"Completed at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    
    print("\n" + "="*60)
    print("ðŸŽ‰ ALL SCRAPING COMPLETE!")
    print("="*60)
    print(f"""
ðŸ“Š FINAL OUTPUT FILES:
   1. {BATCH2_CSV}
      (Remaining 3521 recordings)
   
   2. {COMPLETE_CSV}
      (All 4521 recordings merged)
   
   3. {summary_file}
      (Summary report)

ðŸ“‹ NEXT STEPS:
   1. Check the quality distribution in the complete CSV
   2. Verify durations are calculated correctly
   3. Proceed to Phase 1: Audio Preprocessing
    """)
    
    return df_complete

# ============================================================
# RUN SCRIPT
# ============================================================

if __name__ == "__main__":
    # Check librosa
    if not LIBROSA_AVAILABLE:
        print("="*60)
        print("âš ï¸ LIBROSA NOT INSTALLED")
        print("="*60)
        print("\nDuration calculation requires librosa.")
        print("Install it with: pip install librosa")
        print("\nContinuing without duration calculation...")
        print("You can run the fix script later to add durations.")
        print("="*60)
        input("\nPress ENTER to continue anyway...")
    
    result_df = main()